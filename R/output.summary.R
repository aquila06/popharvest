#' Summary of the output parameters from the \code{PEG} and the \code{PTL} functions
#'
#' The function returns descriptive statistics (mean, median, se and 95 \% confidence intervals) for the output parameters used by PEG and PTL functions. These parameters are : potential excess growth (PEG) or prescribed take level (PTL), sustainable harvest index (SHI), the maximum annual population growth rate (Rmax) and the number of iterations for which the observed harvest exceeds the sustainable harvest index (unsustain.harvest). Descriptive statistics are drawn from the n simulations called within the \code{PEG} and \code{PTL} functions. When one or more parameters are fixed by the user, the corresponding value is reported for mean and median, without any further measure of dispersion (i.e. se and 95 \% CI are equal to zero). Statistics are reported in columns.
#'
#' @param data dataframe generated by the \code{PEG} function or the the \code{PTL} function detailing calculations for each of the n iterations. Other input will give an error.
#'
#' @return A dataframe containing the following statistics calculated over the n iterations:
#' In columns :
#' \itemize{
#'   \item \code{SP} the species
#' }
#' In rows :
#' \itemize{
#'   \item \code{Fs} safety factor or \code{Fobj} objective factor
#'   \item \code{med.Rmax} median of the maximum annual growth rate
#'   \item \code{mean.Rmax} arithmetic mean of the maximum annual growth rate
#'   \item \code{se.Rmax} standard error of the maximum annual growth rate
#'   \item \code{Rmax.CI95.low} lower bound of the 95 \% confidence interval of the maximum annual growth rate
#'   \item \code{Rmax.CI95.up} upper bound of the 95 \% confidence interval of the maximum annual growth rate
#'   \item \code{med.PEG} median of the potential excess growth or \code{med.PTL} median of the maximum theoretical harvest
#'   \item \code{mean.PEG} arithmetic mean of the potential excess growth or \code{mean.PTL} arithmetic mean of the maximum theoretical harvest
#'   \item \code{se.PEG} standard error of the potential excess growth or \code{se.PTL} standard error of the maximum theoretical harvest
#'   \item \code{PEG.CI95.low} lower bound of the 95 \% confidence interval of the potential excess growth or \code{PTL.CI95.low} lower bound of the 95 \% confidence interval of the maximum theoretical harvest
#'   \item \code{PEG.CI95.up} upper bound of the 95 \% confidence interval of the potential excess growth or \code{PTL.CI95.up} upper bound of the 95 \% confidence interval of the maximum theoretical harvest
#'   \item \code{med.SHI} median of the sustainability harvest index
#'   \item \code{mean.SHI} arithmetic mean of the sustainability harvest index
#'   \item \code{se.SHI} standard error of the sustainability harvest index
#'   \item \code{SHI.CI95.low} lower bound of the 95 \% confidence interval of the sustainability harvest index
#'   \item \code{SHI.CI95.up} upper bound of the 95 \% confidence interval of the sustainability harvest index
#'   \item \code{unsustain.harvest} frequency (1 = 100\%) of the n iterations  with sign of overharvesting
#' }
#' @export
#' @seealso \code{\link{PEG}}, \code{\link{PTL}}
#' @importFrom stats var median t.test
#' @importFrom stringr str_sub
#'
#' @examples
#' df <- PEG(Nsim = 20, NSp = 2, living.rate = c("long", "short"),
#' surv.fixed = c(0.8, 0.65),
#' alpha.unif = TRUE, min.alpha = c(2, 1), max.alpha = c(3, 2),
#' pop.fixed = c(3605244, 55805898),
#' harvest.fixed = c(107802, 8447950),
#' Fs = c(0.1, 0.3, 0.5))
#'
#' output.summary(df)
#'
output.summary <- function(data){

  ## I. Error messages ----
  # Printing error messages if the input datas are not correct
  if(is.null(data)){
    stop("'data' must be specified")
  }
  if (!is.data.frame(data)) {
    stop("'data' must be a dataframe")
  }
  if(!is.null(data$PEG) && !is.numeric(data$PEG)){
    stop("'PEG' column must be a numeric vector")
  }
  if(!is.null(data$PTL) && !is.numeric(data$PTL)){
    stop("'PTL' column must be a numeric vector")
  }
  if(is.null(data$SHI)){
    stop("'SHI' column does not exist")
  }
  if(!is.numeric(data$SHI)){
    stop("'SHI' column must be a numeric vector")
  }
  if(is.null(data$Rmax)){
    stop("'Rmax' column does not exist")
  }
  if(!is.numeric(data$Rmax)){
    stop("'Rmax' column must be a numeric vector")
  }



  ## II. Calculations ----
  # Standard error function ----
  se <- function(x) sqrt(var(x)/length(x))

  ## Step 1 : Creation of the end storage vectors to save results of the calculations ----
  Output <- NULL



  ## Step 2 : Creation of the input data filter parameter for the loop of calculations bellow ----
  # This step is necessary to adapt the final data frame according the PEG or PTL function used previously
  col <- which(colnames(data) == "Fs") # Finding if there is a column named "Fs" : if it is TRUE, it means the function previously used is the PEG function and the vector returns a number
  if(length(col)> 0) {  # If the object 'col' is > 0, it implied there is a column named "Fs" in the data frame 'data' and the PEG function was used previously
    data$code <- as.factor(paste0("SP", data$SP, " Fs ", data$Fs)) # Creation of a code which will be used for calculations in the step 3
  } else { # If the output comes from PTL function
    data$code <- as.factor(paste0("SP", data$SP, " Fobj ", data$Fobj)) # Creation of a code which will be used for calculations in the step 3
  }



  ## Step 3 : Loop of calulcations according input data filter parameter ----
  # This step makes it possible to obtain the descriptive statistics of the parameters used as input data
  for (j in levels(data$code)){
    newdata <- subset(data, data$code == j) # Extracting the data frame for which the value of the 'code' column is equal to the level j



    ## Descriptive statistics of PEG ----
    col <- which(colnames(newdata) == "PEG") # Finding if there is a column named "PEG" in the data frame named 'newdata'
    # If the object 'col' is > 0 : In this case, it implied there is a column named "PEG" in the data frame 'data' and the PEG function was used previously
    if(length(col)> 0){
      mean.PEG <- round(mean(newdata$PEG)) # Calculation of the mean rounded to the whole
      med.PEG <- round(median(newdata$PEG)) # Calculating the median rounded to the whole
      if(mean.PEG == round(newdata$PEG[1])){ # If the mean is equal to the first row of the column named 'PEG' (means that all values in the 'PEG' column are the same) then :
        se.PEG <- 0 # Atributting 0 to the standard error object
        PEG.CI95.low <- 0 # Atributting 0 to the lower bound of the interval of confidence at 95 \%
        PEG.CI95.up <- 0 # Atributting 0 to the upper bound of the interval of confidence at 95 \%
        # At this step we must assign 0 manually because otherwise an error message is returned
      }else{ # If the mean is different to the first row of the column named 'PEG' then :
        se.PEG <- round(se(newdata$PEG)) # Calculating the standard error rounded to the whole
        CI.list <- t.test(newdata$PEG) # Calculating the interval of confidence at 95 \%
        CI <- CI.list[[4]] # Extracting the fourth row from the list which returns the lower and the upper bound of the interval of confidence at 95 \%
        PEG.CI95.low <- round(CI[1])  # Extracting the lower bound of the interval of confidence at 95 \% rounded to the whole
        PEG.CI95.up <- round(CI[2])  # Extracting the upper bound of the interval of confidence at 95 \% rounded to the whole
      } # End of condition
    } # End of condition



    ## Descriptive statistics of PTL ----
    col <- which(colnames(newdata) == "PTL") # Finding if there is a column named "PTL" in the data frame named 'newdata'
    # If the object 'col' is > 0 : In this case, it implied there is a column named "PTL" in the data frame 'data' and the PEG function was used previously
    if(length(col)> 0){
      mean.PTL <- round(mean(newdata$PTL)) # Calculation of the mean rounded to the whole
      med.PTL <- round(median(newdata$PTL)) # Calculation of the median rounded to the whole
      if (mean.PTL == round(newdata$PTL[1])) { # If the mean is equal to the first row of the column named 'PTL' (means that all values in the 'PTL' column are the same) then :
        se.PTL <- 0 # Attributing 0 to the standard error
        PTL.CI95.low <- 0 # Atributting 0 to the lower bound of the interval of confidence at 95 \%
        PTL.CI95.up <- 0 # Atributting 0 to the upper bound of the interval of confidence at 95 \%
        # At this step we must assign 0 manually because otherwise an error message is returned
      } else{  # If the mean is different to the first row of the column named 'PTL' then :
        se.PTL <- round(se(newdata$PTL)) # Calculating the standard error rounded to the whole
        CI.list <- t.test(newdata$PTL)  # Calculating the interval of confidence at 95 \%
        CI <- CI.list[[4]] # Extracting the fourth row from the list which returns the lower and the upper bound of the interval of confidence at 95 \%
        PTL.CI95.low <- round(CI[1])  # Extracting the lower bound of the interval of confidence at 95 \% rounded to the whole
        PTL.CI95.up <- round(CI[2])  # Extracting the upper bound of the interval of confidence at 95 \% rounded to the whole
      } # End of condition
    } # End of condition



    ## Descriptive statistics of SHI ----
    mean.SHI <- round(mean(newdata$SHI), 3) # Calculation of the mean rounded to the thousandth
    med.SHI <- round(median(newdata$SHI), 3) # Calculation of the median rounded to the thousandth
    if(mean.SHI == round(newdata$SHI[1], 3)){ # If the mean is equal to the first row of the column named 'SHI' (means that all values in the 'SHI' column are the same) then :
      se.SHI <- 0 # Atributting 0 to the standard error
      SHI.CI95.low <- 0 # Atributting 0 to the lower bound of the interval of confidence at 95 \%
      SHI.CI95.up <- 0 # Atributting 0 to the upper bound of the interval of confidence at 95 \%
      # At this step we must assign 0 manually because otherwise an error message is returned
    }else{ # If the mean is different to the first row of the column named 'SHI' then :
      se.SHI <- round(se(newdata$SHI),3) # Calculating the standard error rounded to the thousandth
      try(CI.list <- t.test(newdata$SHI), silent = TRUE) # Calculating the interval of confidence at 95 \%
      CI <- CI.list[[4]] # Extracting the fourth row from the list which returns the lower and the upper bound of the interval of confidence at 95 \%
      SHI.CI95.low <- round(CI[1], 3) # Extracting the lower bound of the interval of confidence at 95 \% rounded to the thousandth
      SHI.CI95.up <- round(CI[2], 3) # Extracting the upper bound of the interval of confidence at 95 \% rounded to the thousandth
    } # End of condition



    ## Descriptive statistics of Rmax ----
    mean.Rmax <- round(mean(newdata$Rmax), 3) # Calculation of the mean rounded to the thousandth
    med.Rmax <- round(median(newdata$Rmax), 3) # Calculation of the median rounded to the thousandth
    if (mean.Rmax == round(newdata$Rmax[1], 3)) { # If the mean is equal to the first row of the column named 'Rmax' (means that all values in the 'Rmax' column are the same) then :
      se.Rmax <- 0 # Atributting 0 to the standard error
      Rmax.CI95.low <- 0 # Atributting 0 to the lower bound of the interval of confidence at 95 \%
      Rmax.CI95.up <- 0 # Atributting 0 to the upper bound of the interval of confidence at 95 \%
      # At this step we must assign 0 manually because otherwise an error message is returned
    } else{ # If the mean is different to the first row of the column named 'Rmax' then :
      se.Rmax <- round(se(newdata$Rmax), 3) # Calculating the standard error rounded to the thousandth
      CI.list <- t.test(newdata$Rmax) # Calculating the interval of confidence at 95 \%
      CI <- CI.list[[4]] # Extracting the fourth row from the list which returns the lower and the upper bound of the interval of confidence at 95 \%
      Rmax.CI95.low <- round(CI[1], 3) # Extracting the lower bound of the interval of confidence at 95 \% rounded to the thousandth
      Rmax.CI95.up <- round(CI[2], 3) # Extracting the upper bound of the interval of confidence at 95 \% rounded to the thousandth
    } # End of condition



    ## Calculations of Unsustainable harvest ----
    # Number of iterations for which the observed harvest exceeds the sustainable harvest index
    unsustainable.harvest <- ifelse(newdata$SHI > 1, 1, 0) # Atributting 1 when observed harvest exceeds the sustainable harvest index, else atributting 0
    # Sum of iterations for which the observed harvest exceeds the sustainable harvest index
    sum.unsustainable.harvest <- sum(unsustainable.harvest) # Sum of 1
    # Frequency of iterations for which the observed harvest exceeds the sustainable harvest index
    unsustain.harvest.freq <- sum.unsustainable.harvest/nrow(newdata) # Sum of 1 divided by the total number of iterations



    ##  Step 4 : Output datas ----
    # Saving temporary output from the temporary data frame named 'newdata'
    col <- which(colnames(newdata) == "Fs") # Finding if there is a column named "Fs" in the data frame named 'newdata' : if it is TRUE, it means the function previously used is the PEG function and the vector returns a number
    if (length(col) > 0){ # If the object 'col' is > 0, it implied there is a column named "Fs" in the data frame 'newdata' and the PEG function was used previously
      Fs <- unique(newdata$Fs) # Deleting duplicates in the column 'Fs' in the data frame named 'newdata'
      OutputT <- data.frame( # Creating a data frame named 'OutputT' containing descriptive statistics of Rmax, PEG, SHI and unsustain.harvest.freq
        code = newdata$code[1],
        Fs = Fs,
        med.Rmax = med.Rmax,
        mean.Rmax = mean.Rmax,
        se.Rmax = se.Rmax,
        Rmax.CI95.low = Rmax.CI95.low,
        Rmax.CI95.up = Rmax.CI95.up,
        med.PEG = med.PEG,
        mean.PEG = mean.PEG,
        se.PEG = se.PEG,
        PEG.CI95.low = PEG.CI95.low,
        PEG.CI95.up = PEG.CI95.up,
        med.SHI = med.SHI,
        mean.SHI = mean.SHI,
        se.SHI = se.SHI,
        SHI.CI95.low = SHI.CI95.low,
        SHI.CI95.up = SHI.CI95.up,
        unsustain.harvest = unsustain.harvest.freq
      )
    } else { # If there is no column named 'Fs' in the data frame named 'data' then there is a column named 'Fobj' exists
      Fobj <- unique(newdata$Fobj) # Deleting duplicates in the column 'Fs' in the data frame named 'newdata'
      OutputT <- data.frame( # Creating a data frame named 'OutputT' containing descriptive statistics of Rmax, PEG, SHI and unsustain.harvest.freq
        code = newdata$code[1],
        Fobj = Fobj,
        med.Rmax = med.Rmax,
        mean.Rmax = mean.Rmax,
        se.Rmax = se.Rmax,
        Rmax.CI95.low = Rmax.CI95.low,
        Rmax.CI95.up = Rmax.CI95.up,
        med.PTL = med.PTL,
        mean.PTL = mean.PTL,
        se.PTL = se.PTL,
        PTL.CI95.low = PTL.CI95.low,
        PTL.CI95.up = PTL.CI95.up,
        med.SHI = med.SHI,
        mean.SHI = mean.SHI,
        se.SHI = se.SHI,
        SHI.CI95.low = SHI.CI95.low,
        SHI.CI95.up = SHI.CI95.up,
        unsustain.harvest = unsustain.harvest.freq
      )
    } # End of condition



    ## Step 5 : Final ouptut ----
    Output <- rbind(Output, OutputT) # Combining by rows all temporary data frames for each level of j

  } # End of the loop j

  ## Step 6 : Dataframe transposition ----
  code <- as.character(Output$code) # Converting the values of the column named 'code' as a character string
  code <- str_sub(code, 1, 3)  # Extracting a character string which informs the number of the 'SP'
  Output <- t(Output) # Transposition of the data frame named 'Output'
  Output <- as.data.frame(Output)  # Converting the matrix named 'Output' as a data frame

  # Step 7 : Renaming columns
  for(i in 1:ncol(Output)){
    name.col <- code[i]
    colnames(Output)[i] <- name.col
  }

  ## Step 8 : Delete the first row of the table which does not correspond to calculations ----
  Output <- Output[2:nrow(Output),, drop = F]

  ## Step 9 : Converting values of the data frame 'Output' as numeric vectors ----
  for(i in 1:ncol(Output)){
    Output[,i] <- as.numeric(as.character(Output[,i]))
  }

  print(Output)

} # End of the function
